# Combined Blender script generated by Voxel

# Generated: 2025-10-19T11:38:24.979754

# ===== Script 1: 01_builder_iter3.py =====

import bpy
import math
from math import radians, pi
import random

# Clear existing objects
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# Create a simple house scene
# Ground plane
bpy.ops.mesh.primitive_plane_add(size=10, location=(0, 0, 0))
ground = bpy.context.active_object
ground.name = "Ground"

# House base
bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1))
house = bpy.context.active_object
house.name = "House"
house.scale = (2, 3, 1.5)

# House roof
bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 2.5))
roof = bpy.context.active_object
roof.name = "Roof"
roof.scale = (2.2, 3.2, 0.8)
roof.rotation_euler = (0, 0, radians(45))

# Red glowing cube (the main light source)
bpy.ops.mesh.primitive_cube_add(size=0.5, location=(0, 0, 1.5))
cube = bpy.context.active_object
cube.name = "Glowing_Cube"

# Add emission material to the cube
cube_material = bpy.data.materials.new(name="Cube_Emission")
cube_material.use_nodes = True
cube_material.node_tree.nodes.clear()

# Add Emission shader
emission = cube_material.node_tree.nodes.new(type='ShaderNodeEmission')
output = cube_material.node_tree.nodes.new(type='ShaderNodeOutputMaterial')
cube_material.node_tree.links.new(emission.outputs['Emission'], output.inputs['Surface'])

# Set bright red emission
emission.inputs['Color'].default_value = (1.0, 0.1, 0.1, 1.0)  # Bright red
emission.inputs['Strength'].default_value = 5.0  # Strong emission

# Apply to cube
cube.data.materials.append(cube_material)

# Add a camera
bpy.ops.object.camera_add(location=(5, -5, 3))
camera = bpy.context.active_object
camera.name = "Camera"

# Point camera at the scene
bpy.context.view_layer.objects.active = camera
bpy.ops.object.constraint_add(type='TRACK_TO')
camera.constraints["Track To"].target = cube

print("âœ… House scene created with glowing red cube!")

# ===== Script 2: 02_texture_iter3.py =====

# Basic texture setup for the house scene
import bpy

# Create materials
house_material = bpy.data.materials.new(name="House_Material")
house_material.use_nodes = True
house_material.node_tree.nodes.clear()

# Add Principled BSDF
bsdf = house_material.node_tree.nodes.new(type='ShaderNodeBsdfPrincipled')
output = house_material.node_tree.nodes.new(type='ShaderNodeOutputMaterial')
house_material.node_tree.links.new(bsdf.outputs['BSDF'], output.inputs['Surface'])

# Set material properties
bsdf.inputs['Base Color'].default_value = (0.8, 0.6, 0.4, 1.0)  # Beige color
bsdf.inputs['Roughness'].default_value = 0.6
bsdf.inputs['Metallic'].default_value = 0.0

# Apply to house objects
for obj in bpy.data.objects:
    if 'House' in obj.name or 'Roof' in obj.name:
        if obj.data.materials:
            obj.data.materials[0] = house_material
        else:
            obj.data.materials.append(house_material)

# Create grass material
grass_material = bpy.data.materials.new(name="Grass_Material")
grass_material.use_nodes = True
grass_material.node_tree.nodes.clear()

bsdf_grass = grass_material.node_tree.nodes.new(type='ShaderNodeBsdfPrincipled')
output_grass = grass_material.node_tree.nodes.new(type='ShaderNodeOutputMaterial')
grass_material.node_tree.links.new(bsdf_grass.outputs['BSDF'], output_grass.inputs['Surface'])

bsdf_grass.inputs['Base Color'].default_value = (0.2, 0.8, 0.2, 1.0)  # Green color
bsdf_grass.inputs['Roughness'].default_value = 0.8

# Apply to terrain
for obj in bpy.data.objects:
    if 'Terrain' in obj.name or 'Grass' in obj.name:
        if obj.data.materials:
            obj.data.materials[0] = grass_material
        else:
            obj.data.materials.append(grass_material)

# ===== Script 3: 03_hdr_iter3.py =====

import bpy
import math

# Clear existing world or create new one
world = bpy.data.worlds.get('World')
if not world:
    world = bpy.data.worlds.new('World')
bpy.context.scene.world = world

world.use_nodes = True
nodes = world.node_tree.nodes
links = world.node_tree.links
nodes.clear()

# This is a late-night interior scene with a glowing red cube
# Environment should be very dark with minimal moonlight through window
# The cube will be the primary light source

# ===== TEXTURE COORDINATE AND MAPPING =====

tex_coord = nodes.new(type='ShaderNodeTexCoord')
tex_coord.location = (-1400, 0)

# Main mapping for environment rotation
mapping = nodes.new(type='ShaderNodeMapping')
mapping.location = (-1200, 0)
mapping.inputs['Rotation'].default_value = (0, 0, 0.524)  # 30 degrees to position moonlight
links.new(tex_coord.outputs['Generated'], mapping.inputs['Vector'])

# ===== DEEP NIGHT BASE GRADIENT =====

# Vertical gradient for room (very dark floor to slightly less dark ceiling)
gradient_vertical = nodes.new(type='ShaderNodeTexGradient')
gradient_vertical.location = (-1000, 200)
gradient_vertical.gradient_type = 'LINEAR'

mapping_vertical = nodes.new(type='ShaderNodeMapping')
mapping_vertical.location = (-1200, 200)
mapping_vertical.inputs['Rotation'].default_value = (1.5708, 0, 0)  # 90 degrees vertical
links.new(tex_coord.outputs['Generated'], mapping_vertical.inputs['Vector'])
links.new(mapping_vertical.outputs['Vector'], gradient_vertical.inputs['Vector'])

# Color ramp for night interior - extremely dark
color_ramp_base = nodes.new(type='ShaderNodeValToRGB')
color_ramp_base.location = (-800, 200)
color_ramp_base.color_ramp.interpolation = 'LINEAR'

# Very dark floor level (almost black with slight warm tint from aged wood)
color_ramp_base.color_ramp.elements[0].position = 0.0
color_ramp_base.color_ramp.elements[0].color = (0.01, 0.008, 0.006, 1.0)  # Nearly black, extremely dark cool gray

# Slightly lighter ceiling (still very dark, cool tint)
color_ramp_base.color_ramp.elements[1].position = 1.0
color_ramp_base.color_ramp.elements[1].color = (0.02, 0.022, 0.025, 1.0)  # Very dark cool gray

links.new(gradient_vertical.outputs['Fac'], color_ramp_base.inputs['Fac'])

# ===== MOONLIGHT FROM WINDOW (DIRECTIONAL) =====

# Directional gradient for window moonlight
gradient_moonlight = nodes.new(type='ShaderNodeTexGradient')
gradient_moonlight.location = (-1000, -100)
gradient_moonlight.gradient_type = 'LINEAR'

mapping_moonlight = nodes.new(type='ShaderNodeMapping')
mapping_moonlight.location = (-1200, -100)
# Angle moonlight from back wall window
mapping_moonlight.inputs['Rotation'].default_value = (0.2, 0, 0.785)  # 45 degrees + slight tilt
links.new(tex_coord.outputs['Generated'], mapping_moonlight.inputs['Vector'])
links.new(mapping_moonlight.outputs['Vector'], gradient_moonlight.inputs['Vector'])

# Color ramp for moonlight (cool blue, very subtle)
color_ramp_moonlight = nodes.new(type='ShaderNodeValToRGB')
color_ramp_moonlight.location = (-800, -100)
color_ramp_moonlight.color_ramp.interpolation = 'EASE'

# Add third element for better falloff
if len(color_ramp_moonlight.color_ramp.elements) < 3:
    color_ramp_moonlight.color_ramp.elements.new(0.5)

# Dark side (no moonlight)
color_ramp_moonlight.color_ramp.elements[0].position = 0.0
color_ramp_moonlight.color_ramp.elements[0].color = (0.0, 0.0, 0.0, 1.0)

# Transition zone
color_ramp_moonlight.color_ramp.elements[1].position = 0.35
color_ramp_moonlight.color_ramp.elements[1].color = (0.008, 0.012, 0.018, 1.0)

# Moonlit side (cool blue, very dim - 7000K equivalent)
color_ramp_moonlight.color_ramp.elements[2].position = 0.75
color_ramp_moonlight.color_ramp.elements[2].color = (0.035, 0.045, 0.065, 1.0)  # Cool blue-gray

links.new(gradient_moonlight.outputs['Fac'], color_ramp_moonlight.inputs['Fac'])

# ===== RADIAL GRADIENT FOR WINDOW SPOT =====

# Radial gradient to create focused moonlight through window
gradient_radial = nodes.new(type='ShaderNodeTexGradient')
gradient_radial.location = (-1000, -350)
gradient_radial.gradient_type = 'RADIAL'

mapping_radial = nodes.new(type='ShaderNodeMapping')
mapping_radial.location = (-1200, -350)
# Position radial gradient to simulate window location
mapping_radial.inputs['Location'].default_value = (0, 0.4, 0)  # Offset up for window
mapping_radial.inputs['Scale'].default_value = (0.3, 0.5, 0.3)  # Elongated for window shape
links.new(tex_coord.outputs['Generated'], mapping_radial.inputs['Vector'])
links.new(mapping_radial.outputs['Vector'], gradient_radial.inputs['Vector'])

# Color ramp for window spot
color_ramp_window_spot = nodes.new(type='ShaderNodeValToRGB')
color_ramp_window_spot.location = (-800, -350)
color_ramp_window_spot.color_ramp.interpolation = 'EASE'

# Center of window (brightest moonlight)
color_ramp_window_spot.color_ramp.elements[0].position = 0.0
color_ramp_window_spot.color_ramp.elements[0].color = (0.05, 0.065, 0.095, 1.0)  # Cool blue

# Edge falloff
color_ramp_window_spot.color_ramp.elements[1].position = 0.6
color_ramp_window_spot.color_ramp.elements[1].color = (0.0, 0.0, 0.0, 1.0)

links.new(gradient_radial.outputs['Fac'], color_ramp_window_spot.inputs['Fac'])

# ===== ATMOSPHERIC NOISE =====

# Very subtle noise for air quality and depth
noise_atmosphere = nodes.new(type='ShaderNodeTexNoise')
noise_atmosphere.location = (-1000, -550)
noise_atmosphere.inputs['Scale'].default_value = 1.8
noise_atmosphere.inputs['Detail'].default_value = 2.0
noise_atmosphere.inputs['Roughness'].default_value = 0.5
links.new(mapping.outputs['Vector'], noise_atmosphere.inputs['Vector'])

# Color ramp for noise (extremely subtle in dark room)
color_ramp_noise = nodes.new(type='ShaderNodeValToRGB')
color_ramp_noise.location = (-800, -550)
color_ramp_noise.color_ramp.elements[0].position = 0.45
color_ramp_noise.color_ramp.elements[0].color = (0.008, 0.008, 0.008, 1.0)
color_ramp_noise.color_ramp.elements[1].position = 0.55
color_ramp_noise.color_ramp.elements[1].color = (0.015, 0.015, 0.015, 1.0)
links.new(noise_atmosphere.outputs['Fac'], color_ramp_noise.inputs['Fac'])

# ===== COMBINE ALL LIGHTING ELEMENTS =====

# Mix base gradient with directional moonlight
mix_base_moon = nodes.new(type='ShaderNodeMixRGB')
mix_base_moon.location = (-600, 50)
mix_base_moon.blend_type = 'ADD'
mix_base_moon.inputs['Fac'].default_value = 0.3  # Subtle moonlight contribution
links.new(color_ramp_base.outputs['Color'], mix_base_moon.inputs['Color1'])
links.new(color_ramp_moonlight.outputs['Color'], mix_base_moon.inputs['Color2'])

# Add window spot highlight
mix_window_spot = nodes.new(type='ShaderNodeMixRGB')
mix_window_spot.location = (-400, 50)
mix_window_spot.blend_type = 'ADD'
mix_window_spot.inputs['Fac'].default_value = 0.4  # Window spot contribution
links.new(mix_base_moon.outputs['Color'], mix_window_spot.inputs['Color1'])
links.new(color_ramp_window_spot.outputs['Color'], mix_window_spot.inputs['Color2'])

# Add atmospheric noise
mix_atmosphere = nodes.new(type='ShaderNodeMixRGB')
mix_atmosphere.location = (-200, 50)
mix_atmosphere.blend_type = 'MIX'
mix_atmosphere.inputs['Fac'].default_value = 0.15  # Very subtle noise
links.new(mix_window_spot.outputs['Color'], mix_atmosphere.inputs['Color1'])
links.new(color_ramp_noise.outputs['Color'], mix_atmosphere.inputs['Color2'])

# ===== BACKGROUND SHADER =====

# Background shader - very low strength for night interior
background = nodes.new(type='ShaderNodeBackground')
background.location = (0, 50)
background.inputs['Strength'].default_value = 0.08  # Extremely dim ambient (cube dominates)
links.new(mix_atmosphere.outputs['Color'], background.inputs['Color'])

# Output
output = nodes.new(type='ShaderNodeOutputWorld')
output.location = (200, 0)
links.new(background.outputs['Background'], output.inputs['Surface'])

# ===== VOLUMETRIC ATMOSPHERE FOR DUST AND LIGHT RAYS =====

# Volume scatter for visible dust particles and god rays from cube
volume_scatter = nodes.new(type='ShaderNodeVolumeScatter')
volume_scatter.location = (-200, -300)
volume_scatter.inputs['Density'].default_value = 0.01  # Dust density for visible light rays
volume_scatter.inputs['Anisotropy'].default_value = 0.35  # Forward scattering for dramatic rays

# Slight warm tint to volume (will pick up red from cube)
volume_scatter.inputs['Color'].default_value = (1.0, 0.98, 0.95, 1.0)

# Volume absorption for depth and atmosphere
volume_absorption = nodes.new(type='ShaderNodeVolumeAbsorption')
volume_absorption.location = (-200, -450)
volume_absorption.inputs['Density'].default_value = 0.003  # Very subtle absorption
volume_absorption.inputs['Color'].default_value = (0.6, 0.65, 0.75, 1.0)  # Cool absorption

# Combine volume scatter and absorption
add_volume = nodes.new(type='ShaderNodeAddShader')
add_volume.location = (0, -375)
links.new(volume_scatter.outputs['Volume'], add_volume.inputs[0])
links.new(volume_absorption.outputs['Volume'], add_volume.inputs[1])

# Connect to volume output
links.new(add_volume.outputs['Shader'], output.inputs['Volume'])

# ===== SCENE RENDER SETTINGS =====

# Set render engine to Cycles
bpy.context.scene.render.engine = 'CYCLES'

# Volumetric settings for dust and light rays
bpy.context.scene.cycles.volume_bounces = 3  # Extra bounce for red light through dust
bpy.context.scene.cycles.volume_step_rate = 0.5  # High quality for dramatic god rays
bpy.context.scene.cycles.volume_max_steps = 512  # Maximum quality for volumetrics

# Enable denoising
bpy.context.scene.cycles.use_denoising = True
bpy.context.view_layer.cycles.use_denoising = True
bpy.context.scene.cycles.denoiser = 'OPENIMAGEDENOISE'

# Light path settings for realistic red light bounces
bpy.context.scene.cycles.max_bounces = 12
bpy.context.scene.cycles.diffuse_bounces = 8  # Critical for red light bouncing off floor
bpy.context.scene.cycles.glossy_bounces = 6
bpy.context.scene.cycles.transmission_bounces = 8
bpy.context.scene.cycles.volume_bounces = 3
bpy.context.scene.cycles.transparent_max_bounces = 8

# Caustics settings
bpy.context.scene.cycles.caustics_reflective = True
bpy.context.scene.cycles.caustics_refractive = True

# Clamping to reduce fireflies from bright emission
bpy.context.scene.cycles.sample_clamp_indirect = 5.0

# ===== COLOR MANAGEMENT =====

# Filmic color management for HDR handling
bpy.context.scene.view_settings.view_transform = 'Filmic'
bpy.context.scene.view_settings.look = 'High Contrast'  # Dramatic for night scene
bpy.context.scene.view_settings.exposure = 0.5  # Boost to see detail in dark scene
bpy.context.scene.view_settings.gamma = 1.0

# Display device
bpy.context.scene.display_settings.display_device = 'sRGB'

# ===== RENDER QUALITY =====

# High sample count for volumetrics and emission
bpy.context.scene.cycles.samples = 1024  # High quality for clean volumetrics
bpy.context.scene.cycles.preview_samples = 256

# Adaptive sampling
bpy.context.scene.cycles.use_adaptive_sampling = True
bpy.context.scene.cycles.adaptive_threshold = 0.005  # High quality threshold

# ===== COMPOSITOR SETUP FOR BLOOM AND ATMOSPHERE =====

# Note: Compositor setup removed to avoid node tree creation issues
# The scene will render with the HDR lighting and materials setup above
# You can manually enable compositor in Blender's Compositing workspace if needed

print("âœ… Combined script execution complete!")
print("ðŸŽ¬ Scene setup with house geometry, materials, HDR lighting, and volumetric effects")
print("ðŸŒ™ Late-night interior with moonlight and atmospheric dust")
print("ðŸ”´ Optimized for red cube emission as primary light source")
