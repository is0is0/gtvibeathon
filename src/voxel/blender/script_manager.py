"""Manages Blender Python scripts generated by agents."""

import logging
from datetime import datetime
from pathlib import Path
from typing import Optional

from voxel.validation import BlenderScriptValidator, ValidationResult

logger = logging.getLogger(__name__)


class ScriptManager:
    """Manages the lifecycle of generated Blender scripts."""

    def __init__(self, output_dir: Path):
        """
        Initialize the script manager.

        Args:
            output_dir: Base output directory for scripts
        """
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.validator = BlenderScriptValidator()

    def create_session_dir(self, session_name: Optional[str] = None) -> Path:
        """
        Create a new session directory for a generation run.

        Args:
            session_name: Optional name for the session

        Returns:
            Path to the session directory
        """
        if session_name is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            session_name = f"session_{timestamp}"

        session_dir = self.output_dir / session_name
        session_dir.mkdir(parents=True, exist_ok=True)

        # Create subdirectories
        (session_dir / "scripts").mkdir(exist_ok=True)
        (session_dir / "renders").mkdir(exist_ok=True)
        (session_dir / "logs").mkdir(exist_ok=True)

        logger.info(f"Created session directory: {session_dir}")
        return session_dir

    def save_script(
        self,
        script_content: str,
        script_name: str,
        session_dir: Path,
        validate: bool = True,
    ) -> Path:
        """
        Save a generated script to the session directory.

        Args:
            script_content: The Python script content
            script_name: Name for the script file
            session_dir: Session directory path
            validate: Whether to validate the script before saving

        Returns:
            Path to the saved script
        """
        scripts_dir = session_dir / "scripts"
        scripts_dir.mkdir(exist_ok=True)

        script_path = scripts_dir / f"{script_name}.py"
        
        # Validate and fix script if requested
        if validate:
            validation_result = self.validator.validate_script(script_content)
            
            if validation_result.errors:
                logger.error(f"Script validation failed for {script_name}:")
                for error in validation_result.errors:
                    logger.error(f"  - {error}")
                # Save the original script with errors for debugging
                script_path.write_text(script_content)
                return script_path
            
            if validation_result.warnings:
                logger.warning(f"Script validation warnings for {script_name}:")
                for warning in validation_result.warnings:
                    logger.warning(f"  - {warning}")
            
            # Use fixed script if available
            if validation_result.fixed_script:
                script_content = validation_result.fixed_script
                if validation_result.fixes_applied:
                    logger.info(f"Applied fixes to {script_name}: {', '.join(validation_result.fixes_applied)}")
            
            # Log validation success
            logger.info(f"Script validation completed for {script_name} - Status: {'VALID' if validation_result.is_valid else 'INVALID'}")
        
        script_path.write_text(script_content)
        logger.info(f"Saved script: {script_path}")
        return script_path

    def combine_scripts(
        self,
        script_paths: list[Path],
        output_name: str,
        session_dir: Path,
        validate_combined: bool = True,
    ) -> Path:
        """
        Combine multiple scripts into a single file.

        Args:
            script_paths: List of script paths to combine
            output_name: Name for the combined script
            session_dir: Session directory path
            validate_combined: Whether to validate the combined script

        Returns:
            Path to the combined script
        """
        scripts_dir = session_dir / "scripts"
        combined_path = scripts_dir / f"{output_name}.py"

        combined_content = []
        combined_content.append("# Combined Blender script generated by Voxel\n")
        combined_content.append(f"# Generated: {datetime.now().isoformat()}\n")
        combined_content.append("# This script combines multiple agent scripts into a single executable script\n\n")

        # Add standard imports at the top
        combined_content.append("# Standard imports")
        combined_content.append("import bpy")
        combined_content.append("from mathutils import Vector, Euler, Matrix")
        combined_content.append("import bmesh")
        combined_content.append("from math import radians, degrees, pi")
        combined_content.append("import os")
        combined_content.append("from pathlib import Path")
        combined_content.append("\n# ===== Agent Scripts =====\n")

        for i, script_path in enumerate(script_paths, 1):
            if script_path is not None and script_path.exists():
                script_content = script_path.read_text()
                
                # Clean up the script content (remove duplicate imports)
                cleaned_content = self._clean_script_content(script_content, i == 1)
                
                combined_content.append(f"\n# ===== Script {i}: {script_path.name} =====\n")
                combined_content.append(cleaned_content)
                combined_content.append("\n")

        final_script = "\n".join(combined_content)
        
        # Validate the combined script
        if validate_combined:
            validation_result = self.validator.validate_script(final_script)
            
            if validation_result.errors:
                logger.error(f"Combined script validation failed:")
                for error in validation_result.errors:
                    logger.error(f"  - {error}")
                # Save with errors for debugging
                combined_path.write_text(final_script)
                return combined_path
            
            if validation_result.warnings:
                logger.warning(f"Combined script validation warnings:")
                for warning in validation_result.warnings:
                    logger.warning(f"  - {warning}")
            
            # Use fixed script if available
            if validation_result.fixed_script:
                final_script = validation_result.fixed_script
                if validation_result.fixes_applied:
                    logger.info(f"Applied fixes to combined script: {', '.join(validation_result.fixes_applied)}")

        combined_path.write_text(final_script)
        logger.info(f"Combined {len(script_paths)} scripts into {combined_path}")

        return combined_path

    def _clean_script_content(self, content: str, is_first_script: bool = False) -> str:
        """
        Clean up script content by removing duplicate imports and comments.
        
        Args:
            content: Original script content
            is_first_script: Whether this is the first script in the combination
            
        Returns:
            Cleaned script content
        """
        lines = content.split('\n')
        cleaned_lines = []
        
        # Skip import lines for all scripts except the first one
        skip_imports = not is_first_script
        
        for line in lines:
            line_stripped = line.strip()
            
            # Skip import lines if this is not the first script
            if skip_imports and (line_stripped.startswith(('import ', 'from ')) or 
                               line_stripped.startswith('# Standard imports') or
                               line_stripped.startswith('# Imports')):
                continue
            
            # Skip header comments for individual scripts
            if (line_stripped.startswith('# Script Generated by Voxel') or
                line_stripped.startswith('# Scene:') or
                line_stripped.startswith('# Effects:')):
                continue
            
            cleaned_lines.append(line)
        
        return '\n'.join(cleaned_lines)

    def save_concept(self, concept: str, session_dir: Path) -> Path:
        """
        Save the scene concept to the session directory.

        Args:
            concept: The scene concept text
            session_dir: Session directory path

        Returns:
            Path to the saved concept file
        """
        concept_path = session_dir / "concept.md"
        concept_path.write_text(concept)
        logger.info(f"Saved concept: {concept_path}")
        return concept_path

    def save_metadata(
        self,
        metadata: dict,
        session_dir: Path,
    ) -> Path:
        """
        Save session metadata as JSON.

        Args:
            metadata: Metadata dictionary
            session_dir: Session directory path

        Returns:
            Path to the metadata file
        """
        import json

        metadata_path = session_dir / "metadata.json"
        metadata_path.write_text(json.dumps(metadata, indent=2, default=str))
        logger.info(f"Saved metadata: {metadata_path}")
        return metadata_path
