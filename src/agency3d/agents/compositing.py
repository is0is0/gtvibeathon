"""Compositing agent for post-processing effects and node-based compositing."""

import logging
from typing import Dict, Any

from agency3d.core.agent import Agent, AgentRole, AgentConfig

logger = logging.getLogger(__name__)


class CompositingAgent(Agent):
    """Agent responsible for setting up compositor nodes and post-processing effects."""

    def __init__(self, config: AgentConfig, context=None):
        super().__init__(AgentRole.COMPOSITING, config, context)

    def get_system_prompt(self) -> str:
        """Get the system prompt for the compositing agent."""
        return """You are a Blender compositing expert. Your job is to set up compositor nodes for post-processing effects and visual enhancements.

## Your Capabilities:
- Set up compositor node trees
- Add render layers and passes
- Create bloom, glare, and lighting effects
- Implement color correction and grading
- Add depth of field and focus effects
- Create film grain, vignette, and lens distortion
- Set up motion blur and temporal effects
- Add volumetric effects and fog

## Blender Compositor API:

### Enable Compositor:
```python
scene = bpy.context.scene
scene.use_nodes = True
tree = scene.node_tree
nodes = tree.nodes
nodes.clear()
```

### Render Layers:
```python
# Add render layers node
render_layers = nodes.new('CompositorNodeRLayers')
render_layers.location = (0, 0)
```

### Color Correction:
```python
# Color balance
color_balance = nodes.new('CompositorNodeColorBalance')
color_balance.location = (200, 0)

# Hue/Saturation
hue_sat = nodes.new('CompositorNodeHueSat')
hue_sat.location = (200, 100)

# Bright/Contrast
bright_contrast = nodes.new('CompositorNodeBrightContrast')
bright_contrast.location = (200, 200)
```

### Effects:
```python
# Glare (bloom effect)
glare = nodes.new('CompositorNodeGlare')
glare.glare_type = 'BLOOM'
glare.location = (400, 0)

# Blur
blur = nodes.new('CompositorNodeBlur')
blur.location = (400, 100)

# Lens distortion
lens_dist = nodes.new('CompositorNodeLensdist')
lens_dist.location = (400, 200)
```

### Output:
```python
# Composite output
composite = nodes.new('CompositorNodeComposite')
composite.location = (600, 0)

# Viewer (for preview)
viewer = nodes.new('CompositorNodeViewer')
viewer.location = (600, 100)
```

## Guidelines:
1. Create logical node flow from input to output
2. Use appropriate node types for desired effects
3. Set up render layers for different passes
4. Add color correction for cinematic look
5. Include depth of field for realism
6. Add subtle effects that enhance without overwhelming
7. Use mix nodes to blend effects appropriately
8. Set up viewer nodes for real-time preview

Generate complete, working Blender Python scripts that create the requested compositing setup."""

    def generate_script(self, scene_description: str, context: Dict[str, Any]) -> str:
        """Generate a Blender script for compositing based on the scene description."""
        try:
            # Extract compositing requirements from scene description
            effects = self._extract_compositing_requirements(scene_description, context)
            
            # Generate the compositing script
            script = f"""# Compositing Script Generated by Voxel CompositingAgent
# Scene: {scene_description}
# Effects: {', '.join(effects)}

import bpy
from mathutils import Vector

# Get scene and enable compositor
scene = bpy.context.scene
scene.use_nodes = True
tree = scene.node_tree
nodes = tree.nodes
links = tree.links

# Clear existing nodes
nodes.clear()

# Create render layers node
render_layers = nodes.new('CompositorNodeRLayers')
render_layers.location = (0, 0)
render_layers.name = "RenderLayers"

{self._create_color_correction_nodes()}

{self._create_effects_nodes(effects)}

{self._create_output_nodes()}

{self._create_node_connections(effects)}

# Set up render settings for compositing
scene.render.use_compositing = True
scene.render.use_sequencer = False

print("Compositing setup complete with effects: {', '.join(effects)}")
"""
            
            return script
            
        except Exception as e:
            logger.error(f"Error generating compositing script: {e}")
            return f"# Error generating compositing script: {e}"

    def _extract_compositing_requirements(self, scene_description: str, context: Dict[str, Any]) -> list:
        """Extract compositing requirements from scene description."""
        effects = []
        
        # Check for lighting/atmosphere keywords
        lighting_keywords = ['sunset', 'sunrise', 'golden hour', 'warm light', 'glow', 'bloom']
        if any(keyword in scene_description.lower() for keyword in lighting_keywords):
            effects.append("bloom")
        
        # Check for mood keywords
        mood_keywords = ['dark', 'moody', 'dramatic', 'cinematic', 'film', 'gritty']
        if any(keyword in scene_description.lower() for keyword in mood_keywords):
            effects.extend(["color_grading", "vignette", "film_grain"])
        
        # Check for nature keywords
        nature_keywords = ['forest', 'nature', 'outdoor', 'landscape', 'fog', 'mist']
        if any(keyword in scene_description.lower() for keyword in nature_keywords):
            effects.extend(["depth_of_field", "atmospheric"])
        
        # Check for futuristic keywords
        futuristic_keywords = ['cyberpunk', 'futuristic', 'neon', 'sci-fi', 'holographic']
        if any(keyword in scene_description.lower() for keyword in futuristic_keywords):
            effects.extend(["glare", "chromatic_aberration", "lens_flare"])
        
        # Check for underwater keywords
        underwater_keywords = ['underwater', 'ocean', 'sea', 'aquatic', 'submerged']
        if any(keyword in scene_description.lower() for keyword in underwater_keywords):
            effects.extend(["color_tint", "caustics", "underwater_distortion"])
        
        # Check for vintage keywords
        vintage_keywords = ['vintage', 'retro', 'old', 'aged', 'sepia']
        if any(keyword in scene_description.lower() for keyword in vintage_keywords):
            effects.extend(["sepia_tone", "film_grain", "vignette"])
        
        # Always include basic color correction
        if not effects:
            effects = ["color_correction"]
        
        return effects

    def _create_color_correction_nodes(self) -> str:
        """Generate color correction nodes."""
        return """
# Color correction nodes
color_balance = nodes.new('CompositorNodeColorBalance')
color_balance.location = (200, 0)
color_balance.name = "ColorBalance"

# Hue/Saturation
hue_sat = nodes.new('CompositorNodeHueSat')
hue_sat.location = (200, 100)
hue_sat.name = "HueSat"

# Bright/Contrast
bright_contrast = nodes.new('CompositorNodeBrightContrast')
bright_contrast.location = (200, 200)
bright_contrast.name = "BrightContrast"

# Color correction mix
color_mix = nodes.new('CompositorNodeMix')
color_mix.location = (400, 100)
color_mix.blend_type = 'MULTIPLY'
color_mix.name = "ColorMix"
"""

    def _create_effects_nodes(self, effects: list) -> str:
        """Generate effects nodes based on requested effects."""
        script_parts = []
        y_offset = 0
        
        for effect in effects:
            if effect == "bloom":
                script_parts.append(f"""
# Bloom effect
glare = nodes.new('CompositorNodeGlare')
glare.glare_type = 'BLOOM'
glare.location = (600, {y_offset})
glare.name = "Bloom"
glare.threshold = 0.8
glare.size = 9
glare.quality = 'HIGH'
""")
                y_offset += 100
                
            elif effect == "color_grading":
                script_parts.append(f"""
# Color grading
color_ramp = nodes.new('CompositorNodeValToRGB')
color_ramp.location = (600, {y_offset})
color_ramp.name = "ColorGrading"
""")
                y_offset += 100
                
            elif effect == "vignette":
                script_parts.append(f"""
# Vignette effect
ellipse_mask = nodes.new('CompositorNodeEllipseMask')
ellipse_mask.location = (600, {y_offset})
ellipse_mask.name = "VignetteMask"
ellipse_mask.width = 0.8
ellipse_mask.height = 0.8

vignette_mix = nodes.new('CompositorNodeMix')
vignette_mix.location = (800, {y_offset})
vignette_mix.blend_type = 'MULTIPLY'
vignette_mix.name = "VignetteMix"
""")
                y_offset += 100
                
            elif effect == "film_grain":
                script_parts.append(f"""
# Film grain
noise_texture = nodes.new('CompositorNodeTexNoise')
noise_texture.location = (600, {y_offset})
noise_texture.name = "FilmGrain"
noise_texture.noise_type = 'FBM'
noise_texture.scale = 100.0

grain_mix = nodes.new('CompositorNodeMix')
grain_mix.location = (800, {y_offset})
grain_mix.blend_type = 'OVERLAY'
grain_mix.name = "GrainMix"
grain_mix.fac = 0.1
""")
                y_offset += 100
                
            elif effect == "depth_of_field":
                script_parts.append(f"""
# Depth of field
defocus = nodes.new('CompositorNodeDefocus')
defocus.location = (600, {y_offset})
defocus.name = "DepthOfField"
defocus.f_stop = 2.8
defocus.max_radius = 10.0
""")
                y_offset += 100
                
            elif effect == "glare":
                script_parts.append(f"""
# Glare effect
glare = nodes.new('CompositorNodeGlare')
glare.glare_type = 'STREAKS'
glare.location = (600, {y_offset})
glare.name = "Glare"
glare.threshold = 0.9
glare.size = 15
""")
                y_offset += 100
                
            elif effect == "chromatic_aberration":
                script_parts.append(f"""
# Chromatic aberration
lens_dist = nodes.new('CompositorNodeLensdist')
lens_dist.location = (600, {y_offset})
lens_dist.name = "ChromaticAberration"
lens_dist.dispersion = 0.1
""")
                y_offset += 100
                
            elif effect == "underwater_distortion":
                script_parts.append(f"""
# Underwater distortion
wave_texture = nodes.new('CompositorNodeTexWave')
wave_texture.location = (600, {y_offset})
wave_texture.name = "UnderwaterWave"
wave_texture.wave_type = 'BANDS'
wave_texture.wave_scale = 0.1

displace = nodes.new('CompositorNodeDisplace')
displace.location = (800, {y_offset})
displace.name = "UnderwaterDisplace"
""")
                y_offset += 100
                
            elif effect == "sepia_tone":
                script_parts.append(f"""
# Sepia tone
hue_sat_sepia = nodes.new('CompositorNodeHueSat')
hue_sat_sepia.location = (600, {y_offset})
hue_sat_sepia.name = "SepiaTone"
hue_sat_sepia.hue = 0.1
hue_sat_sepia.sat = 0.3
hue_sat_sepia.val = 0.9
""")
                y_offset += 100
        
        return "\n".join(script_parts)

    def _create_output_nodes(self) -> str:
        """Generate output nodes."""
        return """
# Output nodes
composite = nodes.new('CompositorNodeComposite')
composite.location = (1000, 0)
composite.name = "Composite"

# Viewer for real-time preview
viewer = nodes.new('CompositorNodeViewer')
viewer.location = (1000, 100)
viewer.name = "Viewer"

# File output for saving
file_output = nodes.new('CompositorNodeOutputFile')
file_output.location = (1000, 200)
file_output.name = "FileOutput"
file_output.base_path = "/tmp/voxel_output/"
file_output.format.file_format = 'PNG'
"""

    def _create_node_connections(self, effects: list) -> str:
        """Generate node connections based on effects."""
        connections = [
            "# Connect render layers to color correction",
            "links.new(render_layers.outputs[0], color_balance.inputs[1])",
            "links.new(color_balance.outputs[0], hue_sat.inputs[1])",
            "links.new(hue_sat.outputs[0], bright_contrast.inputs[1])",
            "links.new(bright_contrast.outputs[0], color_mix.inputs[1])",
        ]
        
        current_output = "color_mix.outputs[0]"
        
        for effect in effects:
            if effect == "bloom":
                connections.extend([
                    f"# Connect bloom effect",
                    f"links.new({current_output}, glare.inputs[0])",
                    f"links.new(glare.outputs[0], color_mix.inputs[2])",
                ])
                current_output = "color_mix.outputs[0]"
                
            elif effect == "vignette":
                connections.extend([
                    f"# Connect vignette effect",
                    f"links.new({current_output}, vignette_mix.inputs[1])",
                    f"links.new(ellipse_mask.outputs[0], vignette_mix.inputs[0])",
                ])
                current_output = "vignette_mix.outputs[0]"
                
            elif effect == "film_grain":
                connections.extend([
                    f"# Connect film grain",
                    f"links.new({current_output}, grain_mix.inputs[1])",
                    f"links.new(noise_texture.outputs[0], grain_mix.inputs[2])",
                ])
                current_output = "grain_mix.outputs[0]"
                
            elif effect == "depth_of_field":
                connections.extend([
                    f"# Connect depth of field",
                    f"links.new({current_output}, defocus.inputs[0])",
                ])
                current_output = "defocus.outputs[0]"
        
        # Final connections to output
        connections.extend([
            f"# Connect to output nodes",
            f"links.new({current_output}, composite.inputs[0])",
            f"links.new({current_output}, viewer.inputs[0])",
            f"links.new({current_output}, file_output.inputs[0])",
        ])
        
        return "\n".join(connections)
    
    def _parse_response(self, response: str) -> str:
        """Parse the agent response."""
        return response
